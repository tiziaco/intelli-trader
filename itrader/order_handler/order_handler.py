from datetime import timedelta

from .base import OrderBase
from .order import Order, OrderType, OrderStatus
from .compliance_manager.basic_compliance_manager import ComplianceManager
from .position_sizer.variable_sizer import DynamicSizer
from .risk_manager.advanced_risk_manager import RiskManager
from ..events_handler.event import SignalEvent, BarEvent, OrderEvent, PortfolioUpdateEvent

from itrader import logger


class OrderHandler(OrderBase):
	"""
	The OrderHandler class manage the signal event coming from the 
	strategy class.

	It transforms the Signal event in a Suggested order, then send it
	to te Risk Manager (cash check, calculate sl and tp) and finally
	calculate the position size with the Position Sizer

	It is able to manage stop and limit order and it has a pending 
	order queue for active and inactive orders.

	When an order is filled it is sended to the execution handler
	"""
	def __init__(self, events_queue):
		"""
		Parameters
		----------
		events_queue: `Queue object`
			The events queue of the trading system
		"""
		super(OrderHandler, self).__init__(events_queue)
		self.compliance = ComplianceManager(self.portfolios)
		self.position_sizer = DynamicSizer(self.portfolios)
		self.risk_manager = RiskManager(self.portfolios)
		
		self.pending_orders: dict[str, dict[str, Order]] = {}


	def check_pending_orders(self, bar_event: BarEvent):
		"""
		Check the activation conditions of the limit orders in 
		the pending orders list.

		Parameters
		----------
		bar_event : `BarEvent`
			The bar event generated from the Universe module
		"""
		if bool(self.pending_orders):
			for portfolio_id, pending_orders in list(self.pending_orders.items()):
				for order_id, order in list(pending_orders.items()):
					last_close = bar_event.bars[order.ticker]['close']

					if order.type == OrderType.STOP:
						if order.action == 'SELL':
							if last_close < order.price: # SL of a long position
								logger.info('  ORDER MANAGER: Stop Loss order filled: %s',order.ticker)
								order.time = bar_event.time
								self.send_order_event(order)
								self.remove_orders(order.ticker, order.portfolio_id)

						elif order.action == 'BUY':
							if last_close > order.price: # SL of a short position
								logger.info('  ORDER MANAGER: Stop Loss filled: %s',order.ticker)
								order.time = bar_event.time
								self.send_order_event(order)
								self.remove_orders(order.ticker, order.portfolio_id)

					elif order.type == OrderType.LIMIT:
						if order.action == 'SELL':
							if last_close > order.price: # TP of a long position
								logger.info('  ORDER MANAGER: Limit order filled: %s',order.ticker)
								order.time = bar_event.time
								self.send_order_event(order)
								self.remove_orders(order.ticker, order.portfolio_id)

						elif order.action == 'BUY':
							if last_close < order.price: # TP of a short position
								logger.info('  ORDER MANAGER: Limit order filled: %s',order.ticker)
								order.time = bar_event.time
								self.send_order_event(order)
								self.remove_orders(order.ticker, order.portfolio_id)

	def execute_market_orders(self):
		"""
		Execute the market orders if any among the pending orders.
		"""
		if bool(self.pending_orders):
			for portfolio_id, pending_orders in list(self.pending_orders.items()):
				for order_id, order in list(pending_orders.items()):
					if order.type == OrderType.MARKET:
						self.send_order_event(order)
	
	def on_signal(self, signal_event: SignalEvent):
		"""
		This is called by the events handler to process the signal
		generated by a strategy.

		These orders are sized by the PositionSizer object and then
		sent to the RiskManager to verify, modify or eliminate it.

		Once received from the RiskManager they are converted into
		full OrderEvent objects and sent back to the events queue.

		Parameters
		----------
		signal_event : `SignalEvent`
			The signal event generated from the strategy module
		"""
		logger.debug('ORDER HANDLER: processing signal %s => %s, %s$', 
					signal_event.ticker, signal_event.action, round(signal_event.price,4))

		self.compliance.check_compliance(signal_event)
		self.position_sizer.size_order(signal_event)
		self.risk_manager.refine_orders(signal_event)
		# Exit if the signal is not validated
		if not signal_event.verified:
			return
		# The signal is valid, place stop loss and take profit orders
		if signal_event.stop_loss > 0:
			self.add_stop_loss_order(signal_event)
		if signal_event.take_profit > 0:
			self.add_take_profit_order(signal_event)
		# Generate an order event from the validated signal
		new_order = Order.new_order(signal_event)
		self.add_pending_order(new_order)
		#print(f'TEST c:: {self.pending_orders}')
		self.execute_market_orders()

	def on_portfolio_update(self, update_event: PortfolioUpdateEvent):
		"""
		Update the information relative to the active portfolios.
		"""
		self.portfolios = update_event.portfolios
		self.compliance.portfolios = update_event.portfolios
		self.position_sizer.portfolios = update_event.portfolios
		self.risk_manager.portfolios = update_event.portfolios
	
	def add_pending_order(self, order: Order):
		"""
		Add new stop or limit order after the suggested order has been 
		refined by the risk manager.

		Parameters
		----------
		order: `LimitOrder object`
			The stop/limit order object for a specific ticker
		"""
		self.pending_orders.setdefault(order.portfolio_id, {}).setdefault(order.id, order)
	
	def remove_orders(self, ticker, portfolio_id):
		"""
		Remove all the pending orders with the same ticker of the
		order who has been filled

		Parameters
		----------
		ticker: `str`
			The ticker of the order to be removed
		"""
		pd_orders = self.pending_orders[portfolio_id]
		for order_id, order in list(pd_orders.items()):
			if order.ticker == ticker:
				logger.debug('  ORDER MANAGER: Pending order %s %s, %s removed',
					order.type.name, order.action, ticker)
				del self.pending_orders[portfolio_id][order_id]
	
	def modify_order(self, ticker):
		"""
		Modify the filling price of an opened Stop or Limit order
		Usefull for trailing stops.

		Parameters
		----------
		ticker: `str`
			The ticker of the order to be modified
		"""
		# TODO: da implementare
		return

	def add_stop_loss_order(self, signal: SignalEvent):
		"""
		Add a stop order in the pending order queue

		Parameters
		----------
		sized_order: `Order object`
			The sized order generated from the position sizer module
		"""
		#TODO: usare Order.new_order(...) altrimenti l'id non viene generato
		# e rimane sempre sull'ultimo valore precedente
		sl_order = Order.new_stop_order(
			time = signal.time,
			ticker = signal.ticker,
			action = 'BUY' if signal.action == 'SELL' else 'SELL',
			price = signal.stop_loss,
			quantity = signal.quantity,
			strategy_id= signal.strategy_id,
			portfolio_id= signal.portfolio_id
			)
		self.add_pending_order(sl_order)
		logger.debug('  ORDER MANAGER: Stop loss order added: %s, %s $', 
					sl_order.ticker, sl_order.price)

	def add_take_profit_order(self, signal: SignalEvent):
		"""
		Add a limit order in the pending order queue

		Parameters
		----------
		sized_order: `Order object`
			The sized order generated from the position sizer module
		"""
		tp_order = Order.new_limit_order(
			time = signal.time,
			ticker = signal.ticker,
			action = 'BUY' if signal.action == 'SELL' else 'SELL',
			price = signal.take_profit,
			quantity = signal.quantity,
			strategy_id= signal.strategy_id,
			portfolio_id= signal.portfolio_id
			)
		self.add_pending_order(tp_order)
		logger.debug('  ORDER MANAGER: Take profit order added: %s, %s $', 
					tp_order.ticker, tp_order.price)

	def send_order_event(self, order: Order):
		"""
		When a stop/limit order is filled or when a market order is set,
		create an order event to be added to the global events que. 
		This event will be then processed by the execution handler.
		"""
		order_event= OrderEvent.new_order_event(order)
		self.events_queue.put(order_event)
		logger.debug('  ORDER MANAGER: Order sent to the execution handler')
