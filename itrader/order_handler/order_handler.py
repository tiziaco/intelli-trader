from datetime import timedelta
from queue import Queue

from ..portfolio_handler.portfolio_handler import PortfolioHandler
from .base import OrderBase, OrderStorage
from .order import Order, OrderType, OrderStatus
from .compliance_manager.basic_compliance_manager import ComplianceManager
from .position_sizer.variable_sizer import DynamicSizer
from .risk_manager.advanced_risk_manager import RiskManager
from ..events_handler.event import SignalEvent, BarEvent, OrderEvent, PortfolioUpdateEvent
from .storage import OrderStorageFactory

from itrader.logger import get_itrader_logger


class OrderHandler(OrderBase):
	"""
	The OrderHandler class manage the signal event coming from the 
	strategy class.

	It transforms the Signal event in a Suggested order, then send it
	to te Risk Manager (cash check, calculate sl and tp) and finally
	calculate the position size with the Position Sizer

	It is able to manage stop and limit order and it has a pending 
	order queue for active and inactive orders.

	When an order is filled it is sended to the execution handler
	"""
	def __init__(self, events_queue: Queue, portfolio_handler: PortfolioHandler, 
	             order_storage: OrderStorage = None):
		"""
		Parameters
		----------
		events_queue: `Queue object`
			The events queue of the trading system
		portfolio_handler: `PortfolioHandler`
			The portfolio handler instance
		order_storage: `OrderStorage`, optional
			The order storage for storage operations. If None, uses InMemoryOrderStorage.
		"""
		#super(OrderHandler, self).__init__(events_queue)
		self.events_queue = events_queue
		self.portfolio_handler = portfolio_handler
		self.compliance = ComplianceManager(portfolio_handler)
		self.position_sizer = DynamicSizer(portfolio_handler)
		self.risk_manager = RiskManager(portfolio_handler)
		
		# Use provided storage or default to in-memory for backward compatibility
		self.order_storage = order_storage or OrderStorageFactory.create_in_memory()
		
		# Keep reference to pending_orders for backward compatibility
		# This will be deprecated once all code is migrated to use the storage
		self.pending_orders = self.order_storage.pending_orders if hasattr(self.order_storage, 'pending_orders') else {}

		self.logger = get_itrader_logger().bind(component="OrderHandler")
		self.logger.info('Order Handler initialized')


	def check_pending_orders(self, bar_event: BarEvent):
		"""
		Check the activation conditions of the limit orders in 
		the pending orders list.

		Parameters
		----------
		bar_event : `BarEvent`
			The bar event generated from the Universe module
		"""
		pending_orders = self.order_storage.get_pending_orders()
		if bool(pending_orders):
			for portfolio_id, pending_orders_dict in list(pending_orders.items()):
				for order_id, order in list(pending_orders_dict.items()):
					last_close = bar_event.get_last_close(order.ticker)

					if order.type == OrderType.STOP:
						if order.action == 'SELL':
							if last_close < order.price: # SL of a long position
								self.logger.info('Stop Loss order filled: %s, %s',order.ticker, order.action)
								order.time = bar_event.time
								self.send_order_event(order)
								self.remove_orders(order.ticker, order.portfolio_id)

						elif order.action == 'BUY':
							if last_close > order.price: # SL of a short position
								self.logger.info('Stop Loss filled: %s, %s',order.ticker, order.action)
								order.time = bar_event.time
								self.send_order_event(order)
								self.remove_orders(order.ticker, order.portfolio_id)

					elif order.type == OrderType.LIMIT:
						if order.action == 'SELL':
							if last_close > order.price: # TP of a long position
								self.logger.info('Limit order filled: %s, %s',order.ticker, order.action)
								order.time = bar_event.time
								self.send_order_event(order)
								self.remove_orders(order.ticker, order.portfolio_id)

						elif order.action == 'BUY':
							if last_close < order.price: # TP of a short position
								self.logger.info('Limit order filled: %s, %s',order.ticker, order.action)
								order.time = bar_event.time
								self.send_order_event(order)
								self.remove_orders(order.ticker, order.portfolio_id)

	def execute_market_orders(self):
		"""
		Execute the market orders if any among the pending orders.
		After execution, delete it from pending orders.
		"""
		pending_orders = self.order_storage.get_pending_orders()
		if bool(pending_orders):
			for portfolio_id, pending_orders_dict in list(pending_orders.items()):
				for order_id, order in list(pending_orders_dict.items()):
					if order.type == OrderType.MARKET:
						self.send_order_event(order)
						self.order_storage.remove_order(order_id, portfolio_id)
	
	def on_signal(self, signal_event: SignalEvent):
		"""
		This is called by the events handler to process the signal
		generated by a strategy.

		These orders are sized by the PositionSizer object and then
		sent to the RiskManager to verify, modify or eliminate it.

		Once received from the RiskManager they are converted into
		full OrderEvent objects and sent back to the events queue.

		Parameters
		----------
		signal_event : `SignalEvent`
			The signal event generated from the strategy module
		"""
		self.logger.debug('Processing signal %s => %s, %s $', 
					signal_event.ticker, signal_event.action, round(signal_event.price,4))

		self.compliance.check_compliance(signal_event)
		self.position_sizer.size_order(signal_event)
		self.risk_manager.refine_orders(signal_event)
		# Exit if the signal is not validated
		if not signal_event.verified:
			return
		# The signal is valid, place stop loss and take profit orders
		if signal_event.stop_loss > 0:
			self.add_stop_loss_order(signal_event)
		if signal_event.take_profit > 0:
			self.add_take_profit_order(signal_event)
		# Generate an order event from the validated signal
		self.new_order(signal_event)
		self.execute_market_orders()

	def on_portfolio_update(self, update_event: PortfolioUpdateEvent):
		"""
		Update the information relative to the active portfolios.
		"""
		# Note: portfolios are now accessed through portfolio_handler
		# This method is kept for backward compatibility with existing tests
		self.portfolios = update_event.portfolios
		# Update sub-components if they have this attribute
		if hasattr(self.compliance, 'portfolios'):
			self.compliance.portfolios = update_event.portfolios
		if hasattr(self.position_sizer, 'portfolios'):
			self.position_sizer.portfolios = update_event.portfolios
		if hasattr(self.risk_manager, 'portfolios'):
			self.risk_manager.portfolios = update_event.portfolios
	
	def add_pending_order(self, order: Order):
		"""
		Add new stop or limit order after the suggested order has been 
		refined by the risk manager.

		Parameters
		----------
		order: `Order object`
			The stop/limit order object for a specific ticker
		"""
		self.order_storage.add_order(order)
	
	def remove_orders(self, ticker, portfolio_id):
		"""
		Remove all the pending orders with the same ticker of the
		order who has been filled

		Parameters
		----------
		ticker: `str`
			The ticker of the order to be removed
		portfolio_id: `str`
			The portfolio ID
		"""
		count = self.order_storage.remove_orders_by_ticker(ticker, portfolio_id)
		if count > 0:
			self.logger.debug('Removed %d pending orders for ticker %s in portfolio %s',
							count, ticker, portfolio_id)

	def remove_order(self, order_id: str, portfolio_id: str = None) -> bool:
		"""
		Remove an order by its ID from pending orders.
		
		Parameters
		----------
		order_id : str
			The ID of the order to remove
		portfolio_id : str, optional
			The portfolio ID for direct access (more efficient)
			
		Returns
		-------
		bool
			True if order was found and removed, False otherwise
		"""
		removed = self.order_storage.remove_order(order_id, portfolio_id)
		if removed:
			self.logger.debug('Order %s removed', order_id)
		else:
			self.logger.warning('Order %s not found for removal', order_id)
		return removed

	
	def modify_order(self, ticker):
		"""
		Modify the filling price of an opened Stop or Limit order
		Usefull for trailing stops.

		Parameters
		----------
		ticker: `str`
			The ticker of the order to be modified
		"""
		# TODO: da implementare
		return

	def add_stop_loss_order(self, signal: SignalEvent):
		"""
		Add a stop order in the pending order queue

		Parameters
		----------
		sized_order: `Order object`
			The sized order generated from the position sizer module
		"""
		portfolio_id = signal.portfolio_id
		exchange = self.portfolio_handler.get_portfolio(portfolio_id).exchange
		sl_order = Order.new_stop_order(
			time = signal.time,
			ticker = signal.ticker,
			action = 'BUY' if signal.action == 'SELL' else 'SELL',
			price = signal.stop_loss,
			quantity = signal.quantity,
			exchange = exchange,
			strategy_id = signal.strategy_id,
			portfolio_id = signal.portfolio_id
			)
		self.add_pending_order(sl_order)
		self.logger.debug('Stop loss order added: %s, %s $', 
					sl_order.ticker, sl_order.price)

	def add_take_profit_order(self, signal: SignalEvent):
		"""
		Add a limit order in the pending order queue

		Parameters
		----------
		sized_order: `Order object`
			The sized order generated from the position sizer module
		"""
		portfolio_id = signal.portfolio_id
		exchange = self.portfolio_handler.get_portfolio(portfolio_id).exchange
		tp_order = Order.new_limit_order(
			time = signal.time,
			ticker = signal.ticker,
			action = 'BUY' if signal.action == 'SELL' else 'SELL',
			price = signal.take_profit,
			quantity = signal.quantity,
			exchange = exchange,
			strategy_id = signal.strategy_id,
			portfolio_id = signal.portfolio_id
			)
		self.add_pending_order(tp_order)
		self.logger.debug('Take profit order added: %s, %s $', 
					tp_order.ticker, tp_order.price)
	
	def new_order(self, signal: SignalEvent):
		portfolio_id = signal.portfolio_id
		exchange = self.portfolio_handler.get_portfolio(portfolio_id).exchange
		new_order = Order.new_order(signal, exchange)
		self.add_pending_order(new_order)

	def send_order_event(self, order: Order):
		"""
		When a stop/limit order is filled or when a market order is set,
		create an order event to be added to the global events que. 
		This event will be then processed by the execution handler.
		"""
		order_event = OrderEvent.new_order_event(order)
		self.events_queue.put(order_event)
		self.logger.debug('Order sent to the execution handler')
