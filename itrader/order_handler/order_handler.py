from datetime import timedelta
from queue import Queue

from ..portfolio_handler.portfolio_handler import PortfolioHandler
from .base import OrderBase
from .order import Order, OrderType, OrderStatus
from .compliance_manager.basic_compliance_manager import ComplianceManager
from .position_sizer.variable_sizer import DynamicSizer
from .risk_manager.advanced_risk_manager import RiskManager
from ..events_handler.event import SignalEvent, BarEvent, OrderEvent, PortfolioUpdateEvent

from itrader.logger import get_itrader_logger


class OrderHandler(OrderBase):
	"""
	The OrderHandler class manage the signal event coming from the 
	strategy class.

	It transforms the Signal event in a Suggested order, then send it
	to te Risk Manager (cash check, calculate sl and tp) and finally
	calculate the position size with the Position Sizer

	It is able to manage stop and limit order and it has a pending 
	order queue for active and inactive orders.

	When an order is filled it is sended to the execution handler
	"""
	def __init__(self, events_queue: Queue, portfolio_handler: PortfolioHandler):
		"""
		Parameters
		----------
		events_queue: `Queue object`
			The events queue of the trading system
		"""
		#super(OrderHandler, self).__init__(events_queue)
		self.events_queue = events_queue
		self.portfolio_handler = portfolio_handler
		self.compliance = ComplianceManager(portfolio_handler)
		self.position_sizer = DynamicSizer(portfolio_handler)
		self.risk_manager = RiskManager(portfolio_handler)
		
		self.pending_orders: dict[str, dict[str, Order]] = {}

		self.logger = get_itrader_logger().bind(component="OrderHandler")
		self.logger.info('Order Handler initialized')


	def check_pending_orders(self, bar_event: BarEvent):
		"""
		Check the activation conditions of the limit orders in 
		the pending orders list.

		Parameters
		----------
		bar_event : `BarEvent`
			The bar event generated from the Universe module
		"""
		if bool(self.pending_orders):
			for portfolio_id, pending_orders in list(self.pending_orders.items()):
				for order_id, order in list(pending_orders.items()):
					last_close = bar_event.get_last_close(order.ticker)

					if order.type == OrderType.STOP:
						if order.action == 'SELL':
							if last_close < order.price: # SL of a long position
								self.logger.info('Stop Loss order filled: %s, %s',order.ticker, order.action)
								order.time = bar_event.time
								self.send_order_event(order)
								self.remove_orders(order.ticker, order.portfolio_id)

						elif order.action == 'BUY':
							if last_close > order.price: # SL of a short position
								self.logger.info('Stop Loss filled: %s, %s',order.ticker, order.action)
								order.time = bar_event.time
								self.send_order_event(order)
								self.remove_orders(order.ticker, order.portfolio_id)

					elif order.type == OrderType.LIMIT:
						if order.action == 'SELL':
							if last_close > order.price: # TP of a long position
								self.logger.info('Limit order filled: %s, %s',order.ticker, order.action)
								order.time = bar_event.time
								self.send_order_event(order)
								self.remove_orders(order.ticker, order.portfolio_id)

						elif order.action == 'BUY':
							if last_close < order.price: # TP of a short position
								self.logger.info('Limit order filled: %s, %s',order.ticker, order.action)
								order.time = bar_event.time
								self.send_order_event(order)
								self.remove_orders(order.ticker, order.portfolio_id)

	def execute_market_orders(self):
		"""
		Execute the market orders if any among the pending orders.
		After execution, delete it from pending orders.
		"""
		if bool(self.pending_orders):
			for portfolio_id, pending_orders in list(self.pending_orders.items()):
				for order_id, order in list(pending_orders.items()):
					if order.type == OrderType.MARKET:
						self.send_order_event(order)
						del self.pending_orders[portfolio_id][order_id]
	
	def on_signal(self, signal_event: SignalEvent):
		"""
		This is called by the events handler to process the signal
		generated by a strategy.

		These orders are sized by the PositionSizer object and then
		sent to the RiskManager to verify, modify or eliminate it.

		Once received from the RiskManager they are converted into
		full OrderEvent objects and sent back to the events queue.

		Parameters
		----------
		signal_event : `SignalEvent`
			The signal event generated from the strategy module
		"""
		self.logger.debug('Processing signal %s => %s, %s $', 
					signal_event.ticker, signal_event.action, round(signal_event.price,4))

		self.compliance.check_compliance(signal_event)
		self.position_sizer.size_order(signal_event)
		self.risk_manager.refine_orders(signal_event)
		# Exit if the signal is not validated
		if not signal_event.verified:
			return
		# The signal is valid, place stop loss and take profit orders
		if signal_event.stop_loss > 0:
			self.add_stop_loss_order(signal_event)
		if signal_event.take_profit > 0:
			self.add_take_profit_order(signal_event)
		# Generate an order event from the validated signal
		self.new_order(signal_event)
		self.execute_market_orders()

	# def on_portfolio_update(self, update_event: PortfolioUpdateEvent):
	# 	"""
	# 	Update the information relative to the active portfolios.
	# 	"""
	# 	self.portfolios = update_event.portfolios
	# 	self.compliance.portfolios = update_event.portfolios
	# 	self.position_sizer.portfolios = update_event.portfolios
	# 	self.risk_manager.portfolios = update_event.portfolios
	
	def add_pending_order(self, order: Order):
		"""
		Add new stop or limit order after the suggested order has been 
		refined by the risk manager.

		Parameters
		----------
		order: `LimitOrder object`
			The stop/limit order object for a specific ticker
		"""
		self.pending_orders.setdefault(order.portfolio_id, {}).setdefault(order.id, order)
	
	def remove_orders(self, ticker, portfolio_id):
		"""
		Remove all the pending orders with the same ticker of the
		order who has been filled

		Parameters
		----------
		ticker: `str`
			The ticker of the order to be removed
		"""
		pd_orders = self.pending_orders[portfolio_id]
		for order_id, order in list(pd_orders.items()):
			if order.ticker == ticker:
				self.logger.debug('Pending order %s %s, %s removed',
								order.type.name, order.action, ticker)
				del self.pending_orders[portfolio_id][order_id]

	def remove_order(self, order_id: str, portfolio_id: str = None) -> bool:
		"""
		Remove an order by its ID from pending orders.
		
		Parameters
		----------
		order_id : str
			The ID of the order to remove
		portfolio_id : str, optional
			The portfolio ID for direct access (more efficient)
			
		Returns
		-------
		bool
			True if order was found and removed, False otherwise
		"""
		if portfolio_id:
			# Direct access if portfolio_id is provided
			if portfolio_id in self.pending_orders and order_id in self.pending_orders[portfolio_id]:
				order = self.pending_orders[portfolio_id][order_id]
				del self.pending_orders[portfolio_id][order_id]
				# Clean up empty portfolio dict if needed
				if not self.pending_orders[portfolio_id]:
					del self.pending_orders[portfolio_id]
				self.logger.debug('Order %s removed from portfolio %s', order_id, portfolio_id)
				return True
		else:
			# Search all portfolios if portfolio_id not provided
			return self._remove_order_search_all(order_id)
		return False

	def _remove_order_search_all(self, order_id: str) -> bool:
		"""
		Helper method to search and remove an order across all portfolios.
		
		Parameters
		----------
		order_id : str
			The ID of the order to remove
			
		Returns
		-------
		bool
			True if order was found and removed, False otherwise
		"""
		for portfolio_id, orders in list(self.pending_orders.items()):
			if order_id in orders:
				order = orders[order_id]
				del self.pending_orders[portfolio_id][order_id]
				# Clean up empty portfolio dict if needed
				if not self.pending_orders[portfolio_id]:
					del self.pending_orders[portfolio_id]
				self.logger.debug('Order %s removed from portfolio %s', order_id, portfolio_id)
				return True
		self.logger.warning('Order %s not found in pending orders', order_id)
		return False
	
	def modify_order(self, ticker):
		"""
		Modify the filling price of an opened Stop or Limit order
		Usefull for trailing stops.

		Parameters
		----------
		ticker: `str`
			The ticker of the order to be modified
		"""
		# TODO: da implementare
		return

	def add_stop_loss_order(self, signal: SignalEvent):
		"""
		Add a stop order in the pending order queue

		Parameters
		----------
		sized_order: `Order object`
			The sized order generated from the position sizer module
		"""
		portfolio_id = signal.portfolio_id
		exchange = self.portfolios.get(portfolio_id, {}).get('exchange', None)
		sl_order = Order.new_stop_order(
			time = signal.time,
			ticker = signal.ticker,
			action = 'BUY' if signal.action == 'SELL' else 'SELL',
			price = signal.stop_loss,
			quantity = signal.quantity,
			exchange = exchange,
			strategy_id = signal.strategy_id,
			portfolio_id = signal.portfolio_id
			)
		self.add_pending_order(sl_order)
		self.logger.debug('Stop loss order added: %s, %s $', 
					sl_order.ticker, sl_order.price)

	def add_take_profit_order(self, signal: SignalEvent):
		"""
		Add a limit order in the pending order queue

		Parameters
		----------
		sized_order: `Order object`
			The sized order generated from the position sizer module
		"""
		portfolio_id = signal.portfolio_id
		exchange = self.portfolio_handler.get_portfolio(portfolio_id).exchange
		tp_order = Order.new_limit_order(
			time = signal.time,
			ticker = signal.ticker,
			action = 'BUY' if signal.action == 'SELL' else 'SELL',
			price = signal.take_profit,
			quantity = signal.quantity,
			exchange = exchange,
			strategy_id = signal.strategy_id,
			portfolio_id = signal.portfolio_id
			)
		self.add_pending_order(tp_order)
		self.logger.debug('Take profit order added: %s, %s $', 
					tp_order.ticker, tp_order.price)
	
	def new_order(self, signal: SignalEvent):
		portfolio_id = signal.portfolio_id
		exchange = self.portfolio_handler.get_portfolio(portfolio_id).exchange
		new_order = Order.new_order(signal, exchange)
		self.add_pending_order(new_order)

	def send_order_event(self, order: Order):
		"""
		When a stop/limit order is filled or when a market order is set,
		create an order event to be added to the global events que. 
		This event will be then processed by the execution handler.
		"""
		order_event = OrderEvent.new_order_event(order)
		self.events_queue.put(order_event)
		self.logger.debug('Order sent to the execution handler')
