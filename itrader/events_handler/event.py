import pandas as pd
from enum import Enum
from datetime import datetime
from dataclasses import dataclass

EventType = Enum("EventType", "PING BAR UPDATE SIGNAL ORDER FILL")
FillStatus = Enum("FillStatus", "EXECUTED REFUSED")

event_type_map = {
	"PING": EventType.PING,
	"BAR": EventType.BAR,
	"UPDATE": EventType.UPDATE,
	"SIGNAL": EventType.SIGNAL,
	"ORDER": EventType.ORDER,
	"FILL": EventType.FILL
}

fill_status_map = {
	"EXECUTED": FillStatus.EXECUTED,
	"REFUSED": FillStatus.REFUSED,
}

@dataclass
class PingEvent:
	"""
	Handles the event of receiving a new market update tick,
	which is defined as a ticker symbol and associated best
	bid and ask from the top of the order book.
	"""

	time: datetime
	type = EventType.PING

	def __str__(self):
		return f"{self.type}, Time: {self.time}"

	def __repr__(self):
		return str(self)


@dataclass
class BarEvent:
	"""
	Handles the event of receiving a new market
	open-high-low-close-volume bar, as would be generated
	via common data providers.
	"""

	time: datetime
	bars: dict[str, pd.DataFrame]
	type = EventType.BAR

	def __str__(self):
		return f"{self.type}, Time: {self.time}"

	def __repr__(self):
		return str(self)

	def get_last_close(self, ticker) -> float:
		return self.bars[ticker]['Close'].iloc[-1]

@dataclass
class PortfolioUpdateEvent:
	"""
	Handles the event of receiving a new market
	open-high-low-close-volume bar, as would be generated
	via common data providers.
	"""

	time: datetime
	portfolios: dict
	type = EventType.UPDATE

	def __str__(self):
		return f"{self.type}, Time: {self.time}"

	def __repr__(self):
		return str(self)

@dataclass
class SignalEvent:
	"""
	Signal event generated from a Strategy object.
	This is received by the Order handler object that validate and
	send the order to the Execution handler object.

	Parameters
	----------
	time: `timestamp`
		Event time
	ticker: `str`
		The ticker symbol, e.g. 'BTCUSD'.
	direction: `str`
		Direction of the position.
		'BOT' (for long) or 'SLD' (for short)
	action: `str`
		'ENTRY' (for long) or 'EXIT' (for short)
	price: `float`
		Last close price for the instrument
	strategy_id: `str`
		The ID of the strategy who generated the signal
	"""

	time: datetime
	order_type: str
	ticker: str
	action: str
	price: float
	quantity: float
	stop_loss: float
	take_profit: float
	strategy_id: int
	portfolio_id: int
	strategy_setting: dict
	verified: bool = False
	type = EventType.SIGNAL

	def __str__(self):
		return f"{self.type} ({self.ticker}, {self.action}, {round(self.price, 4)} $)"

	def __repr__(self):
		return str(self)


@dataclass
class OrderEvent:
	"""
	An Order object is generated by the OrderHandler in respons to
	a signal event who has been validated by the the PositionSizer 
	and RiskManager object.

	It is then sent to the ExecutionHandler who send the order
	to the exchange.
	"""

	time: datetime
	ticker: str
	action: str
	price: float
	quantity: float
	exchange: str
	strategy_id: int
	portfolio_id: int
	type = EventType.ORDER

	def __str__(self):
		return f"{self.type} ({self.ticker}, {self.action}, {self.quantity}, {round(self.price, 4)} $)"

	def __repr__(self):
		return str(self)
	
	@classmethod
	def new_order_event(cls, order):
		"""
		Generate a new OrderEvent object when an order is filled.

		Parameters
		----------
		signal : `SignalEvent`
			The object representing the signal
		
		Returns
		-------
		Order : `OrderEvent`
			A new Order object with the specified type.
		"""

		return cls(
			order.time,
			order.ticker,
			order.action,
			order.price,
			order.quantity,
			order.exchange,
			order.strategy_id,
			order.portfolio_id
		)


@dataclass
class FillEvent:
	"""
	This event is generated by the ExecutionHandler in response to
	an executed order. 
	Stores the price and quantity and commission confirmed by 
	the exchange.

	Parameters
	----------
	time: `timestamp`
		Event time
	ticker: `str`
		The ticker symbol, e.g. 'BTCUSD'.
	action: `str`
		'BOT' (for long) or 'SLD' (for short)
	quantity: `float`
		Quantity transacted
	price: `float`
		Last close price for the instrument
	commission: `float`
		Transaction fee
	exchange: `str`
		The exchange where to transact, e.g. 'binance'.
	portfolio_id: `str`
		Portfolio id where transact the position
	"""

	time: datetime
	status: FillStatus
	ticker: str
	action: str
	price: float
	quantity: float
	commission: float
	portfolio_id: str
	type = EventType.FILL

	def __str__(self):
		return f'{self.type} ({self.ticker}, {self.action}, {round(self.quantity, 4)}, {round(self.price, 4)} $)'

	def __repr__(self):
		return str(self)
	
	@classmethod
	def new_fill(cls, status: str, commission: float, order: OrderEvent):
		"""
		Generate a new FillEvent object.

		Parameters
		----------
		status : `str`
			The execution state of the fill order e.g. 'EXECUTED', 'REFUSED'
		order : `OrderEvent`
			The instance of the executed order
		
		Returns
		-------
		fill : `FillEvent`
			Instance of the executed order
		"""

		fill_status = fill_status_map.get(status)
		if fill_status is None:
			raise ValueError('Value %s not supported', status)
		return cls(
			order.time,
			fill_status,
			order.ticker,
			order.action,
			order.price,
			order.quantity,
			commission,
			order.portfolio_id
		)