import queue
import logging
from datetime import datetime

from itrader.instances.event import EventType
from itrader.order_manager.order_handler import OrderHandler
from itrader.portfolio_handler.portfolio_handler import PortfolioHandler
from itrader.execution_handler.simulated import ExecutionHandler

logger = logging.getLogger()
logger.setLevel(logging.DEBUG)  # Overall minimum logging level

stream_handler = logging.StreamHandler()  # Configure the logging messages displayed in the Terminal
formatter = logging.Formatter('%(levelname)s | %(message)s') # %(asctime)s 
stream_handler.setFormatter(formatter)
stream_handler.setLevel(logging.INFO)  # Minimum logging level for the StreamHandler

logger.addHandler(stream_handler)

class EventEngine(object):
    """
    Encapsulates all components associated with the engine of the
    trading system. This includes the order handler (with its risk manager 
    and position sizer), the portfolio handler and the execution handler
    (with its transaction cost model).

    It process the signal coming from the strategy handler.

    Parameters
    ----------
    price_handler : `PriceHandler`
        The data handler instance used for all market data.
    global_queue : `Queue`
        The global events queue of the trading system.
    exchange : `str`
        The exchange where to execute real orders.
    init_cash : `int`
        Initial cash for the simulated portfolio
    order_type : `str`
        Order type for the otder handler ('market' or 'limit')
        Default to 'market'
    submit_orders : `Boolean`, optional
        Whether to actually submit live orders. Defaults to no submission.
    """

    def __init__(
        self,
        #universe,
        price_handler,
        global_queue,
        exchange,
        init_cash,
        order_type = 'market',
        submit_orders = False,
        #**kwargs
    ):
        #self.universe = universe
        self.price_handler = price_handler
        self.global_queue = global_queue
        self.init_cash = init_cash
        self.exchange = exchange #TODO: da implementare in Exec.handler
        self.order_type = order_type
        self.submit_orders = submit_orders

        self.engine_queue = None
        self.order_handler = None
        self.portfolio_handler = None
        self.execution_handler = None
        self._continue_loop = True
        self._initialise_engine()



    def _initialise_engine(self):
        """
        Initialise the various components for the engine of the
        trading system. This includes the portfolio, order and
        execution handler.
        """

        # Initialise the engine queue
        self.engine_queue = queue.Queue()


        # Initialise the Portfolio handler
        time = datetime.now()
        self.portfolio_handler = PortfolioHandler(1000, time, self.engine_queue, self.price_handler)

        # Initialise the Order handler
        self.order_handler = OrderHandler(self.engine_queue, self.portfolio_handler, self.order_type)

        # Initialise the Execution handler
        self.execution_handler = ExecutionHandler(self.engine_queue)
    
    def _process_signal(self, event):
        """
        Process the Signal ebent generated by the Strategy module
        """
        self.engine_queue.put(event)

        while not self.engine_queue.empty() :
            self.engine_queue.get(False)
            if event.type == EventType.SIGNAL:
                self.order_handler.on_signal(event)
            elif event.type == EventType.ORDER:
                self.execution_handler.execute_order(event)
            elif event.type == EventType.FILL:
                self.portfolio_handler.on_fill(event)
    
    def run(self):
        """
        Start the trading engine in an infinite loop.
        At every loop, get the event from the global queue and 
        process it.
        """
        logger.info('ENGINE is running')

        while self._continue_loop:
            try:
                event = self.global_queue.get(False)
            except queue.Empty:
                event = None

            if event is not None:
                if (
                    event.type == EventType.TICK or
                    event.type == EventType.BAR
                ):
                    self.cur_time = event.time
                    self.portfolio_handler.update_portfolio_value() # Modif: invertito con la riga sottostante
                    self.order_handler.check_pending_orders(self.price_handler)
                    #self.statistics.update(event.time)
                elif event.type == EventType.SIGNAL:
                    self._process_signal(event)
                else:
                    raise NotImplemented("Unsupported event.type '%s'" % event.type)
        logger.info('ENGINE is stopped')
